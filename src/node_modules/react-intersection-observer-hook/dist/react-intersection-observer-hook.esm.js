import { useRef, useState, useCallback } from 'react';

function createObserverCache() {
  var cachesByRoot = new Map();

  function getObserver(_ref) {
    var root = _ref.root,
        rootMargin = _ref.rootMargin,
        threshold = _ref.threshold;
    var cacheByRoot = cachesByRoot.get(root);

    if (!cacheByRoot) {
      cacheByRoot = new Map();
      cachesByRoot.set(root, cacheByRoot);
    }

    var cacheKey = JSON.stringify({
      rootMargin: rootMargin,
      threshold: threshold
    });
    var cachedObserver = cacheByRoot.get(cacheKey);

    if (!cachedObserver) {
      var entryCallbacks = new Map();
      var observer = new IntersectionObserver(function (entries) {
        entries.forEach(function (entry) {
          var callback = entryCallbacks.get(entry.target);
          callback == null ? void 0 : callback(entry);
        });
      }, {
        root: root,
        rootMargin: rootMargin,
        threshold: threshold
      });
      cachedObserver = {
        observer: observer,
        entryCallbacks: entryCallbacks
      };
      cacheByRoot.set(cacheKey, cachedObserver);
    }

    return {
      observe: function observe(node, callback) {
        var _cachedObserver, _cachedObserver2;

        (_cachedObserver = cachedObserver) == null ? void 0 : _cachedObserver.entryCallbacks.set(node, callback);
        (_cachedObserver2 = cachedObserver) == null ? void 0 : _cachedObserver2.observer.observe(node);
      },
      unobserve: function unobserve(node) {
        var _cachedObserver3, _cachedObserver4;

        (_cachedObserver3 = cachedObserver) == null ? void 0 : _cachedObserver3.entryCallbacks["delete"](node);
        (_cachedObserver4 = cachedObserver) == null ? void 0 : _cachedObserver4.observer.unobserve(node);
      }
    };
  }

  return {
    getObserver: getObserver
  };
}

var DEFAULT_ROOT_MARGIN = '0px';
var DEFAULT_THRESHOLD = [0];
var observerCache = /*#__PURE__*/createObserverCache(); // For more info:
// https://developers.google.com/web/updates/2016/04/intersectionobserver
// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

function useIntersectionObserver(args) {
  var _args$rootMargin, _args$threshold;

  var rootMargin = (_args$rootMargin = args == null ? void 0 : args.rootMargin) != null ? _args$rootMargin : DEFAULT_ROOT_MARGIN;
  var threshold = (_args$threshold = args == null ? void 0 : args.threshold) != null ? _args$threshold : DEFAULT_THRESHOLD;
  var nodeRef = useRef(null);
  var rootRef = useRef(null);
  var observerRef = useRef(null);

  var _useState = useState(),
      entry = _useState[0],
      setEntry = _useState[1];

  var observe = useCallback(function () {
    var node = nodeRef.current;

    if (!node) {
      setEntry(undefined);
      return;
    }

    var observer = observerCache.getObserver({
      root: rootRef.current,
      rootMargin: rootMargin,
      threshold: threshold
    });
    observer.observe(node, function (observedEntry) {
      setEntry(observedEntry);
    });
    observerRef.current = observer;
  }, [rootMargin, threshold]);
  var unobserve = useCallback(function () {
    var currentObserver = observerRef.current;
    var node = nodeRef.current;

    if (node) {
      currentObserver == null ? void 0 : currentObserver.unobserve(node);
    }

    observerRef.current = null;
  }, []); // React will call the ref callback with the DOM element when the component mounts,
  // and call it with null when it unmounts.
  // So, we don't need an useEffect etc to unobserve nodes.
  // When nodeRef.current is null, it will be unobserved and observe function
  // won't do anything.

  var refCallback = useCallback(function (node) {
    unobserve();
    nodeRef.current = node;
    observe();
  }, [observe, unobserve]);
  var rootRefCallback = useCallback(function (rootNode) {
    unobserve();
    rootRef.current = rootNode;
    observe();
  }, [observe, unobserve]);
  return [refCallback, {
    entry: entry,
    rootRef: rootRefCallback
  }];
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function useTrackVisibility(args) {
  var _result$entry;

  var _useIntersectionObser = useIntersectionObserver(args),
      ref = _useIntersectionObser[0],
      result = _useIntersectionObser[1];

  var isVisible = Boolean((_result$entry = result.entry) == null ? void 0 : _result$entry.isIntersecting);

  var _useState = useState(isVisible),
      wasEverVisible = _useState[0],
      setWasEverVisible = _useState[1];

  if (isVisible && !wasEverVisible) {
    setWasEverVisible(true);
  }

  return [ref, _extends({}, result, {
    isVisible: isVisible,
    wasEverVisible: wasEverVisible
  })];
}

export { useIntersectionObserver, useTrackVisibility };
//# sourceMappingURL=react-intersection-observer-hook.esm.js.map
