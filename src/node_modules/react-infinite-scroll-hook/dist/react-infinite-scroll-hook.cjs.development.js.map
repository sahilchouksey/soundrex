{"version":3,"file":"react-infinite-scroll-hook.cjs.development.js","sources":["../src/useInfiniteScroll.ts"],"sourcesContent":["import { useEffect } from 'react';\nimport {\n  useTrackVisibility,\n  IntersectionObserverHookArgs,\n  IntersectionObserverHookRefCallback as UseInfiniteScrollHookRefCallback,\n  IntersectionObserverHookRootRefCallback as UseInfiniteScrollHookRootRefCallback,\n} from 'react-intersection-observer-hook';\n\nconst DEFAULT_DELAY_IN_MS = 100;\n\nexport {\n  UseInfiniteScrollHookRefCallback,\n  UseInfiniteScrollHookRootRefCallback,\n};\n\nexport type UseInfiniteScrollHookResult = [\n  UseInfiniteScrollHookRefCallback,\n  { rootRef: UseInfiniteScrollHookRootRefCallback },\n];\n\nexport type UseInfiniteScrollHookArgs = Pick<\n  IntersectionObserverHookArgs,\n  // We pass this to 'IntersectionObserver'. We can use it to configure when to trigger 'onLoadMore'.\n  'rootMargin'\n> & {\n  // Some sort of \"is fetching\" info of the request.\n  loading: boolean;\n  // If the list has more items to load.\n  hasNextPage: boolean;\n  // The callback function to execute when the 'onLoadMore' is triggered.\n  // eslint-disable-next-line no-undef\n  onLoadMore: VoidFunction;\n  // Flag to stop infinite scrolling. Can be used in case of an error etc too.\n  disabled?: boolean;\n  // How long it should wait before triggering 'onLoadMore'.\n  delayInMs?: number;\n};\n\nfunction useInfiniteScroll({\n  loading,\n  hasNextPage,\n  onLoadMore,\n  rootMargin,\n  disabled,\n  delayInMs = DEFAULT_DELAY_IN_MS,\n}: UseInfiniteScrollHookArgs): UseInfiniteScrollHookResult {\n  const [ref, { rootRef, isVisible }] = useTrackVisibility({\n    rootMargin,\n  });\n\n  const shouldLoadMore = !disabled && !loading && isVisible && hasNextPage;\n\n  // eslint-disable-next-line consistent-return\n  useEffect(() => {\n    if (shouldLoadMore) {\n      // When we trigger 'onLoadMore' and new items are added to the list,\n      // right before they become rendered on the screen, 'loading' becomes false\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\n      // So, it triggers 'onLoadMore' just after the first one is finished.\n      // We use a small delay here to prevent this kind of situations.\n      // It can be configured by hook args.\n      const timer = setTimeout(() => {\n        onLoadMore();\n      }, delayInMs);\n      return () => {\n        clearTimeout(timer);\n      };\n    }\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\n\n  return [ref, { rootRef }];\n}\n\nexport default useInfiniteScroll;\n"],"names":["DEFAULT_DELAY_IN_MS","useInfiniteScroll","loading","hasNextPage","onLoadMore","rootMargin","disabled","delayInMs","useTrackVisibility","ref","rootRef","isVisible","shouldLoadMore","useEffect","timer","setTimeout","clearTimeout"],"mappings":";;;;;;;AAQA,IAAMA,mBAAmB,GAAG,GAA5B;;AA8BA,SAASC,iBAAT;MACEC,eAAAA;MACAC,mBAAAA;MACAC,kBAAAA;MACAC,kBAAAA;MACAC,gBAAAA;4BACAC;MAAAA,wCAAYP;;4BAE0BQ,gDAAkB,CAAC;AACvDH,IAAAA,UAAU,EAAVA;AADuD,GAAD;MAAjDI;;MAAOC,+BAAAA;MAASC,iCAAAA;;AAIvB,MAAMC,cAAc,GAAG,CAACN,QAAD,IAAa,CAACJ,OAAd,IAAyBS,SAAzB,IAAsCR,WAA7D;;AAGAU,EAAAA,eAAS,CAAC;AACR,QAAID,cAAJ,EAAoB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,UAAME,KAAK,GAAGC,UAAU,CAAC;AACvBX,QAAAA,UAAU;AACX,OAFuB,EAErBG,SAFqB,CAAxB;AAGA,aAAO;AACLS,QAAAA,YAAY,CAACF,KAAD,CAAZ;AACD,OAFD;AAGD;AACF,GAfQ,EAeN,CAACV,UAAD,EAAaQ,cAAb,EAA6BL,SAA7B,CAfM,CAAT;AAiBA,SAAO,CAACE,GAAD,EAAM;AAAEC,IAAAA,OAAO,EAAPA;AAAF,GAAN,CAAP;AACD;;;;"}