'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var reactIntersectionObserverHook = require('react-intersection-observer-hook');

var DEFAULT_DELAY_IN_MS = 100;

function useInfiniteScroll(_ref) {
  var loading = _ref.loading,
      hasNextPage = _ref.hasNextPage,
      onLoadMore = _ref.onLoadMore,
      rootMargin = _ref.rootMargin,
      disabled = _ref.disabled,
      _ref$delayInMs = _ref.delayInMs,
      delayInMs = _ref$delayInMs === void 0 ? DEFAULT_DELAY_IN_MS : _ref$delayInMs;

  var _useTrackVisibility = reactIntersectionObserverHook.useTrackVisibility({
    rootMargin: rootMargin
  }),
      ref = _useTrackVisibility[0],
      _useTrackVisibility$ = _useTrackVisibility[1],
      rootRef = _useTrackVisibility$.rootRef,
      isVisible = _useTrackVisibility$.isVisible;

  var shouldLoadMore = !disabled && !loading && isVisible && hasNextPage; // eslint-disable-next-line consistent-return

  react.useEffect(function () {
    if (shouldLoadMore) {
      // When we trigger 'onLoadMore' and new items are added to the list,
      // right before they become rendered on the screen, 'loading' becomes false
      // and 'isVisible' can be true for a brief time, based on the scroll position.
      // So, it triggers 'onLoadMore' just after the first one is finished.
      // We use a small delay here to prevent this kind of situations.
      // It can be configured by hook args.
      var timer = setTimeout(function () {
        onLoadMore();
      }, delayInMs);
      return function () {
        clearTimeout(timer);
      };
    }
  }, [onLoadMore, shouldLoadMore, delayInMs]);
  return [ref, {
    rootRef: rootRef
  }];
}

exports.default = useInfiniteScroll;
//# sourceMappingURL=react-infinite-scroll-hook.cjs.development.js.map
